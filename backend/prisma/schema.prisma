// Prisma Schema for LRN CHAT

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model
model User {
  id                  String   @id @default(uuid())
  username            String   @unique
  email               String?  @unique
  passwordHash        String
  emailVerified       Boolean  @default(false)
  verificationToken   String?
  tokenExpiry         DateTime?
  createdAt           DateTime @default(now())
  lastSeen            DateTime @default(now())
  
  // Relations
  messages              Message[]
  conversationMembers   ConversationMember[]
  encryptionKeys        EncryptionKey[]
  
  @@index([username])
  @@index([email])
  @@index([verificationToken])
}

// Conversation model (supports both direct and group chats)
model Conversation {
  id        String   @id @default(uuid())
  name      String?
  type      ConversationType @default(DIRECT)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  messages Message[]
  members  ConversationMember[]
  
  @@index([createdAt])
}

enum ConversationType {
  DIRECT
  GROUP
}

// Conversation members (many-to-many relationship)
model ConversationMember {
  id             String   @id @default(uuid())
  userId         String
  conversationId String
  role           MemberRole @default(MEMBER)
  joinedAt       DateTime   @default(now())
  
  // Relations
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@unique([userId, conversationId])
  @@index([userId])
  @@index([conversationId])
}

enum MemberRole {
  ADMIN
  MEMBER
}

// Message model (stores encrypted messages)
model Message {
  id               String   @id @default(uuid())
  conversationId   String
  senderId         String
  encryptedContent String   @db.Text
  iv               String   // Initialization vector for AES-GCM
  timestamp        DateTime @default(now())
  deliveredAt      DateTime?
  readAt           DateTime?
  
  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  
  @@index([conversationId, timestamp])
  @@index([senderId])
}

// Encryption keys (for Signal Protocol)
model EncryptionKey {
  id            String   @id @default(uuid())
  userId        String
  conversationId String?
  publicKey     String   @db.Text
  signedPreKey  String?  @db.Text
  keyType       KeyType
  createdAt     DateTime @default(now())
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([conversationId])
}

enum KeyType {
  IDENTITY
  SIGNED_PREKEY
  ONE_TIME_PREKEY
}
